#!/usr/bin/env python3
"""
Validates a generated exploit script.
"""
import os
import sys
import subprocess
from pathlib import Path
from colorama import Fore, Style

def validate_exploit(exploit_script_path: str, target_binary_path: str) -> bool:
    """
    Runs the exploit script and tests its output against the target binary.

    :param exploit_script_path: Path to the Python exploit script.
    :param target_binary_path: Path to the original, uninstrumented binary.
    :return: True if the exploit successfully crashes the target, False otherwise.
    """
    print(f"{Fore.CYAN}[*] Validating exploit: {os.path.basename(exploit_script_path)}{Style.RESET_ALL}")
    exploit_script = Path(exploit_script_path)
    target_binary = Path(target_binary_path)
    work_dir = exploit_script.parent

    if not exploit_script.exists():
        print(f"{Fore.RED}[-] Exploit script not found: {exploit_script}{Style.RESET_ALL}")
        return False
    
    if not target_binary.exists():
        print(f"{Fore.RED}[-] Target binary not found: {target_binary}{Style.RESET_ALL}")
        return False

    # 1. Run the exploit script to generate the malicious file
    print(f"{Fore.YELLOW}  [1/2] Running exploit script to generate payload...{Style.RESET_ALL}")
    try:
        # Run the script in its own directory
        proc = subprocess.run(
            [sys.executable, str(exploit_script)],
            cwd=work_dir,
            capture_output=True, text=True, timeout=30
        )
        
        if proc.returncode != 0:
            print(f"{Fore.RED}[-] Exploit script failed to run:{Style.RESET_ALL}")
            print(f"    Stdout: {proc.stdout}")
            print(f"    Stderr: {proc.stderr}")
            return False
        
        # Look for common payload file names
        payload_candidates = [
            "exploit_payload.dat",
            "exploit.dat",
            "payload.dat",
            "malicious.dat"
        ]
        
        payload_file = None
        for candidate in payload_candidates:
            candidate_path = work_dir / candidate
            if candidate_path.exists():
                payload_file = candidate_path
                break
        
        # If no standard names found, look for newest file
        if not payload_file:
            files = [f for f in work_dir.iterdir() if f.is_file() and f != exploit_script]
            if files:
                payload_file = max(files, key=os.path.getmtime)
        
        if not payload_file or not payload_file.exists():
            print(f"{Fore.RED}[-] No payload file was generated by the exploit script.{Style.RESET_ALL}")
            print(f"    Script output: {proc.stdout}")
            return False

        print(f"{Fore.GREEN}  ✓ Payload generated: {payload_file.name}{Style.RESET_ALL}")

    except subprocess.TimeoutExpired:
        print(f"{Fore.RED}[-] Exploit script timed out during execution{Style.RESET_ALL}")
        return False
    except Exception as e:
        print(f"{Fore.RED}[-] Error running exploit script: {e}{Style.RESET_ALL}")
        return False

    # 2. Run the target binary with the generated malicious file
    print(f"{Fore.YELLOW}  [2/2] Testing payload against target binary...{Style.RESET_ALL}")
    try:
        # Test with the payload file as argument
        result = subprocess.run(
            [str(target_binary), str(payload_file)],
            capture_output=True, text=True, timeout=10, cwd=work_dir
        )
        
        # Check for crash indicators
        if result.returncode < 0:
            signal_num = abs(result.returncode)
            signal_names = {11: "SIGSEGV", 6: "SIGABRT", 4: "SIGILL", 8: "SIGFPE"}
            signal_name = signal_names.get(signal_num, f"Signal {signal_num}")
            print(f"{Fore.GREEN}  ✓ SUCCESS: Target crashed with {signal_name}! Exploit is valid.{Style.RESET_ALL}")
            return True
        elif result.returncode != 0:
            print(f"{Fore.YELLOW}  ? Target exited with code {result.returncode}. May indicate an issue.{Style.RESET_ALL}")
            print(f"    Stderr: {result.stderr[:200]}...")
            return False
        else:
            print(f"{Fore.RED}  ✗ FAILURE: Target exited normally (code 0). Exploit did not crash the target.{Style.RESET_ALL}")
            return False

    except subprocess.TimeoutExpired:
        print(f"{Fore.GREEN}  ✓ SUCCESS: Target hung/timed out! This often indicates a successful exploit.{Style.RESET_ALL}")
        return True
    except FileNotFoundError:
        print(f"{Fore.RED}[-] Could not execute target binary: {target_binary}{Style.RESET_ALL}")
        return False
    except Exception as e:
        print(f"{Fore.RED}[-] Error running target binary: {e}{Style.RESET_ALL}")
        return False

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <path_to_exploit.py> <path_to_uninstrumented_binary>")
        sys.exit(1)
    
    is_valid = validate_exploit(sys.argv[1], sys.argv[2])
    if is_valid:
        print(f"\n{Fore.GREEN}Validation Result: SUCCESS{Style.RESET_ALL}")
        print("SUCCESS")  # This line is checked by the main script
    else:
        print(f"\n{Fore.RED}Validation Result: FAILED{Style.RESET_ALL}")
        print("FAILED")

if __name__ == '__main__':
    main()